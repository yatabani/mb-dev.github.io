---
tags: ['study-notes', 'cloud']
---


# Coursera - Cloud Computing 2 - Week 2

## RPC
### Why RPC?
- Allow process to call functions in other processes.
- In local procedure call the arguments are passed by the stack and common objects can be referred to using pointers.
- In RPC pointers can't be used.

### Semantics
- At most once semantics - Java RMI
- At least once semantics - Sun RPC
- Maybe i.e. best effort COBRA

| Semantic      | Re-transmit Request | Filter duplicate | Re-execute function |
|---------------|---------------------|------------------|---------------------|
| At least once | Yes                 | No               | Re-execute          |
| At most once  | Yes                 | Yes              | Re-transmit         |
| Maybe         | No                  | N/A              | N/A                  |

- Idempotent operations can be used with at-least-once semantics.

### Components
- P1 - (caller() <-> Client stub <-> Communication module) <-> P2 (communication module <-> dispatcher <-> server stub <-> callee())
- Client stub has same signature as callee. Server stub calls callee and allows it to return a value.
- The stubs are usually auto generated by the RPC system.

### Marshallings
- Data is marshalled to platform independent format.
- Need to be aware of [Big endian vs. little endian](http://en.wikipedia.org/wiki/Endianness).

## Transactions
- It's all or nothing. Either commit (all operations were performed) or abort.
- Example
  - transactionId = openTransaction()
  - x = server.getFlightAvailability(ABC, 123, date)
  - if (x > 0) server.bookTicket(ABC, 123, date)
  - server.putSeat(y, 'aisle')
  - closeTransaction(transactionId)

### ACID
- Atomicity (all or nothing)
- Consistency (data saved must pass all validation rules, triggers etc.)
- Isolation (invisible to other transactions)
- Durability (After transaction completed successfully, the effects are saved to storage)

[Serial equivalence](http://www.it.uom.gr/teaching/distrubutedSite/dist-sys/ds-node220.html):
- Operations that are performed in parallel have same end-result as if they executed sequentially.
- Two reads do not conflict
- read/write then read/write do not conflict
- read and write by different transactions can conflict
- write and write by different transactions can conflict

### Pessimistic
Assume the worst, prevent transactions from accessing the same object. e.g locking
- Each object has a lock, at most one transaction can be inside a lock. Before reading or writing object O, transaction T must call lock(O)
- After entering lock T, can read and write multiple times
- When done, T calls unlock(O). (This is similar to mutual exclusion)

Exclusive concurrency reduces concurrency. Alternative mode:

- Each object has a lock that can be held in two modes: Read mode (multiple transactions allowed in), Write mode (exclusive lock)
- Before first reading O, transaction T calls read_lock(O)
  - T allowed in only if all transactions inside the lock for O entered in read mode
  - Not allowed if any transaction inside lock for O entered via write mode.
- Before writing O, call write_lock(O), allowed in only if no other transactions are inside the lock.
  - If T already holds read_lock(O) but wants to write, call write_lock(O) to promote lock from read to write.

**Two phase commit:**

- Transaction cannot acquire or promote locks after it started releasing locks.  Either transaction is in state of **acquiring** locks or in state of **releasing** locks.

Downsides of locking - **deadlocks**:
- For deadlock to occur all three conditions must occur (and can be fixed by not allowing conditon)
  1. Some objects are accessed in exclusive lock mode (Fix: only allow reads)
  2. Transaction holding locks keeps holding the locks (Fix: allow some locks to timeout)
  3. There is a circular wait in the Wait-for-graph (Fix: lock all objects in the beginning, if any fail to lock - abort transaction)


### Optimistic
Assume the best, allow transactions to write, but check later.

**Basic approach:**

- Allow write and read.
- Check for serial equivalence at commit time
- IF abort, roll back updates made
- An abort may result in other transactions that read dirty data also being aborted. (Cascading aborts)

**Timestamp ordering:**

- Assign each transaction an id
- Transaction id determines it's position in serialized order.
- Ensure for each transaction T:
  - T write to object O is allowed, only if other read/write had lower ids
  - T read of object O is allowed only if O was last written by transaction with lower id
- Maintained using timestamps
- If the rules are violated - abort.

**Multi-version concurrency control:**

- For each object:
  - A per transaction version of the object is maintained. Marked as tentative version and committed version.
  - Each tentative version has a timestamp
    - Some systems maintain both a read timestamp and write timestamp
  - On read or write, find the correct tentative version to read or write from. "Correct" based on transaction id, and tries to make transactions only read from "immediately previous" transactions.

** Eventual consistency in DynamoDB: **

- Only one version of each data item (key-value pair)
- Last write wins by timestamp
- Can have issues with unsynchronized clocks.

** Eventual consistency in Riak: **

- Uses vector clocks
- Implements casual ordering to determine if write are committed or **sibling value** value is created and need to be handled by application.

## Replication
Object has identical copies, each maintained by a separate servers. Used for fault tolerance, load balancing and higher availability.

- Replication transparency - client should not be aware of multiple copies of object. Is provided using a front-end (driver, cloud) that routes the request to one of replicas.
- Replication consistency - all clients see a single consistent copy of data. For transactions: guarantee ACID

### Passive replication
Uses a primary replica (master)

- One replica is elected as master. Writes goes directly to the master
- For reads - any of the replicas can be accessed

### Active replication
Treats all replicas identically

- Multicast to the replica group.

### Two phase commit

![](TwoPhaseCommit.png)

- There is a similar rule for serial operations - one copy serializability - transactions should behave the same as though there is only one replica.
- Coordinator server (elected using election protocol) - sends prepare message. If all is okay, reply with Yes.
- If any returned No or timeout, send abort to all servers
- Otherwise, commit is sent, commit is saved, OK is returned back.

**Failures:**

- To deal with server crashes: Each server saves tentative updates to permanent storage right before replying Yes/No.
- To deal with coordinator crashes: Coordinator logs all decisions and received/sent messages on disk
- To deal with Commit or Abort message loss - server can poll coordinator (repeatedly)

### Paxos
- Paxos can be used for atomic commits but need to ensure aborts if any server votes no.
- Paxos can also be used for ordering updates.
